generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
}

model User {
  id            String           @id @default(uuid())
  email         String
  firstName     String?
  lastName      String?
  password      String?          @db.VarChar(255)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  deletedAt     DateTime?
  avatarUrl     String?
  provider      String?
  socialId      String?
  twoFactorEnabled Boolean @default(false)
  twoFactorSecret  String?
  whitelistedIps   Json?           @default("[]")
  addresses     Address[]
  auditLogs     AuditLog[]
  carts         Cart[]
  inventoryLogs InventoryLog[]
  notifications Notification[]
  orders        Order[]
  reviews       Review[]
  permissions   UserPermission[]
  roles         UserRole[]
  wishlist      Wishlist[]
  blogs         Blog[]
  conversations ChatConversation[]
  aiChatSessions AiChatSession[]

  // Multi-tenancy
  tenantId      String?
  tenant        Tenant? @relation(fields: [tenantId], references: [id])

  @@index([email])
  @@index([tenantId])
  @@index([tenantId, createdAt(sort: Desc)]) // For tenant user listing
  @@unique([tenantId, email])
  @@unique([id, tenantId])
}

model Role {
  id          String           @id @default(uuid())
  name        String
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  permissions RolePermission[]
  users       UserRole[]

  // Multi-tenancy
  tenantId      String?
  tenant        Tenant? @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, name])
  @@index([tenantId])
}

model Permission {
  id        String           @id @default(uuid())
  name      String           @unique
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  roles     RolePermission[]
  users     UserPermission[]
}

model UserRole {
  userId String
  roleId String
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([roleId])
}

model RolePermission {
  roleId       String
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
}

model UserPermission {
  userId       String
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, permissionId])
  @@index([permissionId])
}

model Category {
  id              String     @id @default(uuid())
  name            String
  slug            String
  parentId        String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  deletedAt       DateTime?
  imageUrl        String?
  metaDescription String?
  metaKeywords    String?
  metaTitle       String?
  parent          Category?  @relation("CategoryToCategory", fields: [parentId], references: [id])
  children        Category[] @relation("CategoryToCategory")
  products        ProductToCategory[]

  // Multi-tenancy
  tenantId      String
  tenant        Tenant? @relation(fields: [tenantId], references: [id])

  @@index([parentId])
  @@index([tenantId])
  @@index([tenantId, parentId])
  @@index([tenantId, createdAt(sort: Desc)])
  @@unique([tenantId, slug])
  @@unique([tenantId, name])
  @@unique([id, tenantId])
}

model Brand {
  id        String    @id @default(uuid())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
  imageUrl  String?
  products  Product[]

  // Multi-tenancy
  tenantId  String
  tenant    Tenant? @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@index([tenantId, createdAt(sort: Desc)])
  @@unique([tenantId, name])
  @@unique([id, tenantId])
}

model Product {
  id              String               @id @default(uuid())
  name            String               @db.VarChar(255)
  slug            String               @db.VarChar(255)
  description     String?
  brandId         String
  categories      ProductToCategory[]
  metadata        Json?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  deletedAt       DateTime?
  metaDescription String?
  metaKeywords    String?
  metaTitle       String?
  maxPrice        Decimal?             @db.Decimal(20, 2)
  minPrice        Decimal?             @db.Decimal(20, 2)
  avgRating       Float?               @default(0)
  reviewCount     Int                  @default(0)

  // Vector Embedding (768 dimensions for Gemini text-embedding-004)
  // Requires pgvector extension. Enable if available.
  // embedding       Unsupported("vector(768)")?

  products        BlogProduct[]
  brand           Brand                @relation(fields: [brandId], references: [id])
  images          ProductImage[]
  options         ProductOption[]
  translations    ProductTranslation[]
  reviews         Review[]
  skus            Sku[]
  wishlists       Wishlist[]

  // Multi-tenancy
  tenantId      String
  tenant        Tenant? @relation(fields: [tenantId], references: [id])

  // ============================================================
  // PERFORMANCE INDEXES (Production-ready)
  // ============================================================
  
  // 1. Brand + Price Range Filter
  // Covers: WHERE brandId = Y AND minPrice >= A AND maxPrice <= B
  @@index([brandId, minPrice, maxPrice, createdAt(sort: Desc)], name: "idx_product_brand_price")
  
  // 2. Price Range (25% of queries)
  // Covers: WHERE minPrice >= A ORDER BY createdAt DESC
  @@index([minPrice, maxPrice, createdAt(sort: Desc)], name: "idx_product_price_range")
  
  // 3. Brand Filter (15% of queries)
  // Covers: WHERE brandId = X ORDER BY createdAt DESC
  @@index([brandId, createdAt(sort: Desc)], name: "idx_product_brand_created")
  
  // 4. Price Sorting (10% of queries)
  // Covers: ORDER BY minPrice ASC/DESC
  @@index([minPrice, createdAt(sort: Desc)], name: "idx_product_price_asc")
  @@index([maxPrice(sort: Desc), createdAt(sort: Desc)], name: "idx_product_price_desc")
  
  // 5. Slug Lookup (already unique, optimized by default)
  // No need for additional index
  
  // 6. Active Products Filter (80% of queries need this)
  // Partial index: WHERE deletedAt IS NULL
  @@index([deletedAt, createdAt(sort: Desc)], name: "idx_product_active")
  
  // 7. Rating Filter (for "top rated" queries)
  // Covers: WHERE avgRating >= 4 ORDER BY avgRating DESC
  @@index([avgRating(sort: Desc), reviewCount(sort: Desc)], name: "idx_product_rating")
  
  // 8. Search Optimization (B-tree indexing for common searches)
  @@index([name])
  @@index([description])
  @@index([metadata], type: Gin)
  
  // Legacy indexes (keep for backward compatibility, will remove in next version)
  // No duplicate name index here
  @@index([slug])

  @@index([deletedAt])
  @@index([tenantId])
  @@index([tenantId, deletedAt])
  @@index([tenantId, brandId, deletedAt])
  @@index([tenantId, minPrice, maxPrice, deletedAt])
  @@unique([tenantId, slug])
  @@index([tenantId, deletedAt, createdAt]) // For Storefront listings
  @@unique([id, tenantId])
}

model ProductToCategory {
  productId  String
  categoryId String
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([productId, categoryId])
  @@index([categoryId])
  @@index([productId])
}

model ProductOption {
  id           String        @id @default(uuid())
  name         String        @db.VarChar(50)
  displayOrder Int?
  productId    String
  values       OptionValue[]
  product      Product       @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
}

model OptionValue {
  id          String             @id @default(uuid())
  value       String             @db.VarChar(50)
  imageUrl    String?
  optionId    String
  option      ProductOption      @relation(fields: [optionId], references: [id], onDelete: Cascade)
  skuVariants SkuToOptionValue[]

  @@index([optionId])
}

model Sku {
  id            String             @id @default(uuid())
  skuCode       String             @db.VarChar(50)
  productId     String
  price         Decimal?           @db.Decimal(20, 2)
  salePrice     Decimal?           @db.Decimal(20, 2)
  stock         Int                @default(0)
  imageUrl      String?
  status        String             @default("INACTIVE")
  metadata      Json?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  reservedStock Int                @default(0)
  cartItems     CartItem[]
  inventoryLogs InventoryLog[]
  orderItems    OrderItem[]
  reviews       Review[]
  optionValues  SkuToOptionValue[]
  images        SkuImage[]
  product       Product            @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Multi-tenancy
  tenantId      String
  tenant        Tenant? @relation(fields: [tenantId], references: [id])

  @@index([productId])
  @@index([skuCode])
  @@index([tenantId])
  @@index([metadata], type: Gin)
  @@index([tenantId, productId, status])
  @@unique([tenantId, skuCode])
  @@unique([id, tenantId])
}

model SkuToOptionValue {
  skuId         String
  optionValueId String
  optionValue   OptionValue @relation(fields: [optionValueId], references: [id], onDelete: Cascade)
  sku           Sku         @relation(fields: [skuId], references: [id], onDelete: Cascade)

  @@id([skuId, optionValueId])
}

model Address {
  id            String   @id @default(uuid())
  userId        String
  isDefault     Boolean  @default(false)
  recipientName String
  phoneNumber   String
  street        String
  city          String
  district      String
  ward          String?
  postalCode    String?
  country       String?  @db.VarChar(100)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  districtId    Int?
  provinceId    Int?
  wardCode      String?
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  orders        Order[]

  // Multi-tenancy
  tenantId      String
  tenant        Tenant? @relation(fields: [tenantId], references: [id])

  @@index([userId])
  @@index([tenantId])
}

model Cart {
  id        String     @id @default(uuid())
  userId    String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     CartItem[]

  // Multi-tenancy
  tenantId  String
  tenant    Tenant?    @relation(fields: [tenantId], references: [id])

  @@unique([userId, tenantId])
}

model CartItem {
  id        String   @id @default(uuid())
  cartId    String
  skuId     String
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  cart      Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  sku       Sku      @relation(fields: [skuId], references: [id], onDelete: Cascade)

  @@unique([cartId, skuId])
  @@index([skuId])
}

model Coupon {
  id                String       @id @default(uuid())
  code              String
  discountType      DiscountType
  discountValue     Decimal      @db.Decimal(20, 2)
  minOrderAmount    Decimal?     @db.Decimal(20, 2)
  maxDiscountAmount Decimal?     @db.Decimal(20, 2)
  startDate         DateTime
  endDate           DateTime
  usageLimit        Int?
  usedCount         Int          @default(0)
  isActive          Boolean      @default(true)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  description       String?
  orders            Order[]

  // Multi-tenancy
  tenantId    String
  tenant      Tenant?  @relation(fields: [tenantId], references: [id])

  @@index([code])
  @@index([tenantId])
  @@unique([tenantId, code])
  @@unique([id, tenantId])
}

model Order {
  id              String        @id @default(uuid())
  userId          String
  status          OrderStatus   @default(PENDING)
  totalAmount     Decimal       @db.Decimal(20, 2)
  shippingFee     Decimal       @default(0.00) @db.Decimal(20, 2)
  recipientName   String
  phoneNumber     String
  shippingAddress String? // Street address or full address
  shippingCity    String?
  shippingDistrict String?
  shippingWard    String?
  shippingPhone   String?
  shippingAddressSnapshot Json? // Full snapshot { street: "", city: "", district: "", ... }
  paymentMethod   String?
  paymentStatus   PaymentStatus @default(UNPAID)
  transactionId   String? // Legacy, will move to Payment model
  payments        Payment[]
  orderDate       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  createdAt       DateTime      @default(now())
  deletedAt       DateTime?
  couponId        String?
  addressId       String?
  shippingCode    String?
  ghnStatus       String?
  expectedDeliveryTime DateTime?
  cancellationReason String?
  coupon          Coupon?       @relation(fields: [couponId], references: [id])
  address         Address?      @relation(fields: [addressId], references: [id])
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  items           OrderItem[]

  // Multi-tenancy
  tenantId      String
  tenant        Tenant? @relation(fields: [tenantId], references: [id])

  @@index([couponId])

  // ============================================================
  // PERFORMANCE INDEXES (Production-ready)
  // ============================================================
  
  // 1. User Order History (50% of queries)
  // Covers: WHERE userId = X ORDER BY createdAt DESC
  @@index([userId, createdAt(sort: Desc)], name: "idx_order_user_history")
  
  // 2. User + Status Filter (30% of queries)
  // Covers: WHERE userId = X AND status IN ('PENDING', 'PROCESSING')
  @@index([userId, status, createdAt(sort: Desc)], name: "idx_order_user_status")
  
  // 3. Admin Dashboard (15% of queries)
  // Covers: WHERE status = 'PENDING' ORDER BY createdAt DESC
  @@index([status, createdAt(sort: Desc)], name: "idx_order_status_date")
  
  // 4. Payment Status Filter (5% of queries)
  // Covers: WHERE paymentStatus = 'UNPAID' AND createdAt < X (for auto-cancel)
  @@index([paymentStatus, createdAt], name: "idx_order_payment_created")
  
  // 5. Shipping Code Lookup
  @@index([shippingCode], name: "idx_order_shipping_code")

  @@index([tenantId])
  @@index([tenantId, status, createdAt]) // For Tenant Admin Dashboard
  @@unique([id, tenantId])
}

model OrderItem {
  id              String  @id @default(uuid())
  orderId         String
  skuId           String
  quantity        Int
  priceAtPurchase Decimal @db.Decimal(20, 2)
  order           Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  sku             Sku     @relation(fields: [skuId], references: [id])
  
  // Denormalized Data for Historial Integrity & Performance
  productName     String?
  skuNameSnapshot String?
  productSlug     String?
  imageUrl        String?


  @@unique([orderId, skuId])
  @@index([skuId])
}

model Review {
  id         String    @id @default(uuid())
  userId     String
  productId  String
  rating     Int       @db.SmallInt
  content    String?
  isApproved Boolean   @default(false)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  deletedAt  DateTime?
  skuId      String?
  images     String[]
  reply      String?
  replyAt    DateTime?
  product    Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  sku        Sku?      @relation(fields: [skuId], references: [id])
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Multi-tenancy
  tenantId   String
  tenant     Tenant?   @relation(fields: [tenantId], references: [id])

  // AI Analysis
  sentiment    Sentiment?
  autoTags     String[] // ["shipping_issue", "product_quality", "service"]

  @@unique([userId, productId, skuId])
  @@index([productId, rating])
  @@index([skuId])
  @@index([tenantId])
  @@index([tenantId, productId, isApproved, createdAt(sort: Desc)])
  @@index([sentiment])
}

enum Sentiment {
  POSITIVE
  NEGATIVE
  NEUTRAL
}

model AuditLog {
  id        String   @default(uuid())
  userId    String?
  action    String
  resource  String
  payload   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])

  @@id([id, createdAt])
  @@index([userId])
  @@index([resource])
  @@index([action])
  @@index([payload], type: Gin)
}

model ProductTranslation {
  id          String  @id @default(uuid())
  productId   String
  locale      String
  name        String  @db.VarChar(255)
  description String?
  product     Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, locale])
  @@index([productId])
  @@index([locale])
}

model ProductImage {
  id           String  @id @default(uuid())
  url          String
  alt          String?
  displayOrder Int     @default(0)
  productId    String
  product      Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
}

model SkuImage {
  id           String  @id @default(uuid())
  url          String
  alt          String?
  displayOrder Int     @default(0)
  skuId        String
  sku          Sku     @relation(fields: [skuId], references: [id], onDelete: Cascade)

  @@index([skuId])
}

model Notification {
  id        String   @id @default(uuid())
  type      String
  title     String
  message   String
  isRead    Boolean  @default(false)
  link      String?
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
}

model InventoryLog {
  id            String   @id @default(uuid())
  skuId         String
  changeAmount  Int
  previousStock Int
  newStock      Int
  reason        String
  userId        String?
  createdAt     DateTime @default(now())
  sku           Sku      @relation(fields: [skuId], references: [id], onDelete: Cascade)
  user          User?    @relation(fields: [userId], references: [id])

  // Multi-tenancy
  tenantId      String
  tenant        Tenant?  @relation(fields: [tenantId], references: [id])

  @@index([skuId])
  @@index([userId])
  @@index([tenantId])
}

model Wishlist {
  id        String   @id @default(uuid())
  userId    String
  productId String
  createdAt DateTime @default(now())
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Multi-tenancy
  tenantId  String
  tenant    Tenant?  @relation(fields: [tenantId], references: [id])

  @@unique([userId, productId])
  @@index([userId])
  @@index([tenantId])
  @@index([tenantId, userId, createdAt(sort: Desc)])
}

model Blog {
  id          String        @id @default(uuid())
  title       String        @db.VarChar(255)
  slug        String        @db.VarChar(255)
  excerpt     String
  content     String
  image       String?       @db.VarChar(500)
  category    String        @db.VarChar(100)
  author      String        @db.VarChar(100)
  language    String        @default("en") @db.VarChar(5)
  readTime    String?       @db.VarChar(20)
  publishedAt DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  deletedAt   DateTime?
  userId      String?
  user        User?         @relation(fields: [userId], references: [id])
  products    BlogProduct[]

  // Multi-tenancy
  tenantId    String
  tenant      Tenant?     @relation(fields: [tenantId], references: [id])

  @@index([slug])
  @@index([tenantId])
  @@index([tenantId, category])
  @@index([tenantId, publishedAt(sort: Desc)])
  @@unique([tenantId, slug])
  @@index([category])
  @@index([language])
  @@index([publishedAt])
  @@index([userId])
  @@index([deletedAt])
}

model BlogProduct {
  blogId    String
  productId String
  createdAt DateTime @default(now())
  blog      Blog     @relation(fields: [blogId], references: [id], onDelete: Cascade)
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@id([blogId, productId])
  @@index([blogId])
  @@index([productId])
}

model FeatureFlag {
  id          String   @id @default(uuid())
  key         String   @unique
  description String?
  isEnabled   Boolean  @default(false)
  rules       Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Multi-tenancy
  tenantId    String
  tenant      Tenant?  @relation(fields: [tenantId], references: [id])

  @@index([key])
  @@index([tenantId])
}

enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
}

enum PaymentStatus {
  UNPAID
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}

model Payment {
  id              String        @id @default(uuid())
  orderId         String
  amount          Decimal       @db.Decimal(20, 2)
  currency        String        @default("VND")
  status          PaymentStatus @default(PENDING)
  paymentMethod   String        // MOMO, VNPAY, STRIPE, COD
  providerTransactionId String? // ID từ phía cổng thanh toán
  metadata        Json?         // Lưu log response từ Gateway
  paidAt          DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  order           Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Multi-tenancy
  tenantId        String
  tenant          Tenant? @relation(fields: [tenantId], references: [id])

  @@index([orderId])
  @@index([status])
  @@index([tenantId])
}

model NewsletterSubscriber {
  id        String   @id @default(uuid())
  email     String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Multi-tenancy
  tenantId  String
  tenant    Tenant? @relation(fields: [tenantId], references: [id])

  @@index([email])
  @@index([tenantId])
  @@unique([tenantId, email])
}

model ChatConversation {
  id        String        @id @default(uuid())
  userId    String
  isActive  Boolean       @default(true)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id])
  messages  ChatMessage[]

  @@index([userId])
  @@index([updatedAt])
  @@unique([userId])
}

model ChatMessage {
  id             String           @id @default(uuid())
  conversationId String
  senderId       String
  senderType     SenderType       @default(USER)
  content        String
  type           MessageType      @default(TEXT)
  metadata       Json?
  isRead         Boolean          @default(false)
  sentAt         DateTime         @default(now())
  conversation   ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([sentAt])
}

enum SenderType {
  USER
  ADMIN
}

enum MessageType {
  TEXT
  IMAGE
  PRODUCT
  ORDER
}

model PerformanceMetric {
  id             String   @default(uuid())
  name           String   // LCP, FID, CLS, FCP, TTFB, INP
  value          Float
  rating         String   // good, needs-improvement, poor
  url            String
  userAgent      String?
  navigationType String?
  createdAt      DateTime @default(now())

  @@id([id, createdAt])
  @@index([name])
  @@index([createdAt])
}

// =====================================================================
// AI CHAT - Tính năng chat với AI sử dụng Google Gemini
// =====================================================================

model AiChatSession {
  id        String   @id @default(uuid())
  userId    String?  // null = guest user
  guestId   String?  // UUID stored in localStorage for guest
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  messages  AiChatMessage[]

  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([guestId])
  @@index([createdAt])
}

model AiChatMessage {
  id        String   @id @default(uuid())
  sessionId String
  role      AiChatRole // user | assistant
  content   String   @db.Text
  metadata  Json?    // product IDs mentioned, tokens used, etc.
  createdAt DateTime @default(now())

  session   AiChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
}

enum AiChatRole {
  USER
  ASSISTANT
}

// =====================================================================
// RELIABILITY - Transactional Outbox Pattern
// =====================================================================

model OutboxEvent {
  id            String    @id @default(uuid())
  aggregateType String    // e.g. "ORDER"
  aggregateId   String    // e.g. Order ID
  type          String    // e.g. "ORDER_CREATED"
  payload       Json
  createdAt     DateTime  @default(now())
  processedAt   DateTime?
  status        OutboxStatus @default(PENDING)
  error         String?

  @@index([status, createdAt])
}

enum OutboxStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// =====================================================================
// MULTI-TENANCY
// =====================================================================

model Tenant {
  id            String      @id @default(uuid())
  name          String
  
  // Domain Management
  subdomain     String?     @unique // e.g., "shop-a" -> shop-a.platform.com
  customDomain  String?     @unique // e.g., "mycustomstore.com"
  domain        String      @unique // Main domain used for resolution (legacy support)
  
  // Settings & Localization
  currency      String      @default("VND")
  timezone      String      @default("Asia/Ho_Chi_Minh")
  locale        String      @default("vi-VN")
  
  // Branding & Assets
  themeConfig   Json?       // { primaryColor: "...", secondaryColor: "...", borderRadius: "..." }
  logoUrl       String?
  faviconUrl    String?
  
  // Business Information
  contactEmail  String?
  contactPhone  String?
  address       String?
  
  // Lifecycle & Status
  plan          TenantPlan  @default(BASIC)
  isActive      Boolean     @default(true)
  suspendedAt   DateTime?
  suspensionReason String?
  
  // Infrastructure
  dbUrl         String?     // If set, this tenant uses a dedicated database (Silo Mode)

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  users       User[]
  products    Product[]
  orders      Order[]
  blogs       Blog[]
  reviews     Review[]
  carts       Cart[]
  wishlists   Wishlist[]
  addresses   Address[]
  inventoryLogs InventoryLog[]
  featureFlags  FeatureFlag[]
  pages         Page[]
  translations  Translation[]
  categories    Category[]
  brands        Brand[]
  coupons       Coupon[]
  skus          Sku[]
  roles         Role[]
  newsletterSubscribers NewsletterSubscriber[]
  payments              Payment[]
  
  // Analytics
  metrics       StoreMetrics[]
  
  // Billing
  subscription  Subscription?
  invoices      Invoice[]
}

model StoreMetrics {
  id            String    @id @default(uuid())
  tenantId      String
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  date          DateTime  @default(now())
  totalOrders   Int       @default(0)
  totalRevenue  Decimal   @db.Decimal(20, 2) @default(0)
  totalVisits   Int       @default(0)
  conversionRate Float     @default(0)
  
  @@unique([tenantId, date])
  @@index([tenantId])
}

model Translation {
  id        String   @id @default(uuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  locale    String   // 'en', 'vi'
  key       String   // 'home.welcome'
  value     String   // 'Welcome to My Custom Store'
  
  updatedAt DateTime @updatedAt

  @@unique([tenantId, locale, key])
  @@index([tenantId, locale])
}

enum TenantPlan {
  BASIC
  PRO
  ENTERPRISE
}

model Page {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  slug        String   // e.g., "/" or "/about-us"
  title       String
  isPublished Boolean  @default(true)
  
  // The magic: JSON-based Block Structure
  // [ { "type": "Hero", "props": { ... } }, { "type": "ProductGrid", "props": { ... } } ]
  blocks      Json     @default("[]") 

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime?

  @@unique([tenantId, slug]) // Enforce unique slugs per tenant
  @@index([tenantId])
}

// =====================================================================
// BILLING & SUBSCRIPTIONS
// =====================================================================

model Subscription {
  id              String           @id @default(uuid())
  tenantId        String           @unique // 1 Tenant has 1 Active Subscription
  plan            TenantPlan
  billingFrequency BillingFrequency @default(MONTHLY)
  startDate       DateTime         @default(now())
  nextBillingDate DateTime
  isActive        Boolean          @default(true)
  cancelAtPeriodEnd Boolean        @default(false)
  
  tenant          Tenant           @relation(fields: [tenantId], references: [id])
  invoices        Invoice[]

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
}

model Invoice {
  id              String        @id @default(uuid())
  tenantId        String
  subscriptionId  String?
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("VND")
  status          InvoiceStatus @default(PENDING)
  description     String?
  paidAt          DateTime?
  dueDate         DateTime
  
  tenant          Tenant        @relation(fields: [tenantId], references: [id])
  subscription    Subscription? @relation(fields: [subscriptionId], references: [id])

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([tenantId])
  @@index([status])
}

enum BillingFrequency {
  MONTHLY
  YEARLY
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
  VOID
}
